[{"authors":["admin"],"categories":null,"content":"I am a masters student at TUM, focusing on Machine Learning, Robotics and Formal Methods. I have experience as a software engineer from my time with Samsung Research, Bangladesh. My research interests lie in designing intelligent deep models and applying them in various paradigms. I have a keen interest in using deep learning to improve reinforcement learning systems.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://abyaadrafid.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a masters student at TUM, focusing on Machine Learning, Robotics and Formal Methods. I have experience as a software engineer from my time with Samsung Research, Bangladesh. My research interests lie in designing intelligent deep models and applying them in various paradigms. I have a keen interest in using deep learning to improve reinforcement learning systems.","tags":null,"title":"Rafid Abyaad","type":"authors"},{"authors":[],"categories":[],"content":"In this post, we will be looking at the paper PnPNet: End-to-End Perception and Prediction with Tracking in the Loop, by Liang et al., which was published in CVPR 2020 [1]. After defining our task and discussing some related research in this field, we will be looking at the methodology of the paper. Then we will analyze the quantitative results and have a look at the qualitative results. Finally, we will finish it off with some remarks and possible ideas for extension.\nIntroduction In the context of self-driving vehicles, predicting the motion of other vehicles is a critical task. Approximating the trajectory of neighboring agents in the future is equally as important as detecting them in the current time frame. To do this task, so far three paradigms have been proposed.\nThe first divide this problem into three separate sub-tasks, which are handled by completely independent sub-systems. These three tasks, namely, object detection, object tracking, and motion forecasting are done sequentially. As they are developed separately, they need more computing power and cannot correct mistakes from upstream tasks. The second paradigm tries to solve the detection and prediction task with a single neural network. This yields more efficient computation but these models suffer from limited use of temporal history and are vulnerable to occlusion.\n\rThree paradigms of perception and prediction problems [1]\n\rThis paper introduces the new third paradigm. It argues that, for sequential modeling tasks such as motion forecasting, past data is very important. To that end, it proposes PnPNet which combines multi-object tracking with joint perception and prediction models. We will go into the details of the model after discussing some other works that try to tackle different aspects of our problem.\nRelated works 3D object detection The use of depth sensors such as LiDARs has been shown to have better performance [2] than cameras for 3D detection. Some works also explore a fusion of LiDAR point clouds and camera inputs [3]. \rA qualitative result of fusion models [3]\n\rMulti-Object Tracking Multi-Object tracking is a system to track multiple objects at the same time. It consists of a discrete data association problem and a continuous trajectory estimation problem [4]. There have been efforts to handle occlusion with hand-crafted heuristics [5] and single object tracking [6] to handle occlusion. To handle the trajectory problem, some approaches also use sensor features but only use up to 3 seconds of temporal history [7].\n\rAn example of multi-object tracking takes from [8]\n\rMotion Forecasting Different methods try to approach the multi-agent motion forecasting problem. Alahi et al. propose LSTM based social pooling to model motion [9]. Social-GAN [10] improves on it using adversarial training. The use of sensor features is also explored, but these methods usually have generalization issues when applied to noisy data [11].\nJoint models for Perception and Prediction The FAF paper [12] of Luo et al. serves as a direct predecessor and an evaluation baseline for PnPNet. This model uses a single convolutional backbone to detect and predict future motion. NeuralMP [13] shares motion planning features with perception and prediction to allow end-to-end training.\n\rSome qualitative results from NeuralMP [13]\n\rProposed method: PnPNet Technical Contributions The discussed related research overlook an important aspect of our problem. They do not take the temporal characteristics of actors into account. To allow for that, this paper makes two major technical contributions :\n It introduces a new trajectory representation based on a sequence of detections through time. It proposes a multi-object tracker that solves both the association and the trajectory estimation problem.  Model Overview PnPNet consists of three separate modules :\n 3D Object detection module Discrete-Continuous Tracking module Motion forecasting module  \rA summary of PnPNet workflow [1]\n\r3D Object detection module The detection module takes multi-sweep LiDAR point cloud representation in birds-eye-view and an HD map as input. Optionally, geometric and semantic information of the HD map can also be used. 2D convolutional neural network-based backbone is applied to the input, which generates the intermediate BEV features that will be used in downstream tasks. A convolutional detection header is then used on the intermediate features to create dense object detections at each time step.\n\rWorkflow of the 3D detection module\n\rDiscrete-Continuous Tracking module As discussed in the related works, there are two separate challenges in multi-object tracking. Previous works mostly focus on the discrete problem of data association but PnPNet also takes the continuous problem of trajectory estimation into account. The paper argues that it helps to prevent association errors from accumulating over time and reduces the variance in motion history. To that end, it proposes a two-stage tracking framework. To use the framework, rich and concise trajectory level object representation need to be learned.\n\rTrajectory level representation generation\n\rThe representation learning problem is formulated as a sequence modeling problem. We use the intermediate FEV features from the backbone network and the location information of each object at time t to run a Bilinear Interpolation. This output is regarded as the representation of the motion of each object from the start frame to the current frame. Along with this, the absolute velocities of each object are passed into an MLP/feed-forward network. The merged features from this FF network are then used as the sequential input for our LSTM. This LSTM hidden state is our trajectory level representation at each time step.\nData Association The first stage of the tracking framework is the discrete tracker. At time t, given Nt detections and Mt-1 trajectories, it tries to determine the associations between them. This association problem is formulated as a bipartite graph matching problem. As a result, one-to-one matching is guaranteed. The edge values for our bipartite matching problem are the affinity values, which represent how likely is a track Mt-1 to belong to detection Nt. The affinity matrix : $$ C_{i,j} = \\begin{cases} MLP_{pair}(f(D_{i}^t); h(P_{j}^{t−1})) \u0026amp; if\\ 1 ≤ j ≤ M_{t−1}\\\\\nMLP_{unary}(f(D_{i}^t)) \u0026amp; if\\ j = M_{t−1} + i \\\\\n−inf \u0026amp; otherwise \\\\\n\\end{cases} $$ The affinity values are calculated with binary or unary MLPs. If we have more or equal number of tracks at the previous step than detections at this step, we use the binary MLP. Otherwise, the unary MLP is used. This bipartite system is solved optimally using the Hungarian algorithm. We use single object tracking for older unmatched tracks. Combining results from bipartite matching and SOT yields a final set of tracks Pt.\nSingle object tracking The single object tracker used in the PnPNet paper follows nearly the same methodology as the Siamese tracker [14]. The Siamese tracker has two networks. One of these twin networks receives an exemplar image as input, another one receives a search image as input. The task for the twin network is to try and find the exemplar image within the search image.\n\rSiamese tracker from [14].\n\rSiamese trackers usually have a cross-correlation layer at the end. PnPNet chooses to replace this layer with an MLP with learnable parameters.\nHungarian Algorithm The Hungarian algorithm is an optimization algorithm that produces the best one-to-one matching when applied to a bipartite graph. In our context, two sets of nodes are the detections and the tracks, denoted as N and M respectively. The edges between these sets of nodes are the affinity values, denoted by a. Here we see an example formulation :\ngraph TD;\rid1((\u0026quot;N\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot; ---id2((\u0026quot;M\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;));\rid1((\u0026quot;N\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;4\u0026lt;/sub\u0026gt;\u0026quot; ---id3((\u0026quot;M\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;));\rid1((\u0026quot;N\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;7\u0026lt;/sub\u0026gt;\u0026quot; ---id4((\u0026quot;M\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;));\rid6((\u0026quot;N\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot; ---id2((\u0026quot;M\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;));\rid6((\u0026quot;N\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;5\u0026lt;/sub\u0026gt;\u0026quot; ---id3((\u0026quot;M\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;));\rid6((\u0026quot;N\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;8\u0026lt;/sub\u0026gt;\u0026quot; ---id4((\u0026quot;M\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;));\rid7((\u0026quot;N\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot; ---id2((\u0026quot;M\u0026lt;sub\u0026gt;1\u0026lt;/sub\u0026gt;\u0026quot;));\rid7((\u0026quot;N\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;6\u0026lt;/sub\u0026gt;\u0026quot; ---id3((\u0026quot;M\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;\u0026quot;));\rid7((\u0026quot;N\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;))-- \u0026quot;a\u0026lt;sub\u0026gt;9\u0026lt;/sub\u0026gt;\u0026quot; ---id4((\u0026quot;M\u0026lt;sub\u0026gt;3\u0026lt;/sub\u0026gt;\u0026quot;));\r Hungarian algorithm will find the best matching that maximizes the overall affinity value throughout the graph.\nTrajectory Estimation Trajectory estimation is the second stage in our two-stage tracking network. This module re-evaluates each object track for the new observation at the current frame and helps minimize false positives and localization errors from upstream tasks. The LSTM representation is refined by an MLP according to the current association. The MLP outputs a confidence score and center position offset. $$ score_{i}, \\Delta u_{i}^{t-T_0+1:t}, \\Delta v_{i}^{t-T_0+1:t} = MLP_{refine}(h(P_{i}^t)) $$ Using these confidence scores, a non-maximal suppression is applied and only top Mt tracks are accepted. Other tracks are discarded as false positives.\nMotion Forecasting module Earlier joint perception and prediction models design the prediction module as another convolutional header. However, PnPnet puts tracking on the detection backbone and creates object trajectory representation. This trajectory representation is then passed through an MLP to estimate motion prediction for each object we are tracking. $$ \\Delta u_{i}^{t:t+\\Delta T}, \\Delta v_{i}^{t:t+\\Delta T} = MLP_{refine}(h(P_{i}^t)) $$ Here $\\Delta T$ is a parameter of the model that denotes the prediction horizon.\nEnd-to-End Training To train PnPNet end-to-end, a multi-task loss is calculated from the individual losses of its three modules. $$ L = L_{detect}+ L_{track} + L_{predict} $$ Here the detection loss is the cross-entropy loss and the smoothed l1 loss over bounding boxes. The tracking loss is again another multi-task loss defined as : $$ L_{track} = L_{score}^{affinity} + L_{score}^{sot} + L_{score}^{refine} + L_{reg}^{refine} $$ The max-margin loss is applied to the sot scores, the trajectory scores, and the affinity matrix. $$ L_{score} = \\frac{1}{N_{i,j}} \\sum_{i \\epsilon{pos}, j \\epsilon{neg}} max(0, m − (a_i − a_j)) $$ Here Ni,j is the total number of positive and negative pairs, where ai and aj are scores for positive and negative samples accordingly.\nFor the prediction task, the loss is just the smoothed l1 loss of the predictions.\nThe Adam optimizer is used to train PnPNet with a frame rate of 10Hz. At each frame maximum M = 50 tracks and N = 50 detections are maintained. The prediction horizon is set $\\Delta T$= 3 seconds with 0.5 seconds interval.\nDatasets and Metrics The PnPNet paper tests itself on two major driving datasets. The performance of PnPNet is measured from modular metrics of detection and tracking, as well as from system metrics for end-to-end perception and prediction.\nnuScenes Dataset [15] This dataset consists of 1000 20-seconds long log snippets with LiDAR sweeps and 3D labels for objects and corresponding HD maps. Although this dataset has some caveats because it only has 84 unique driving journeys, and 63.5% of the cars are parked.\n\rAn example from nuScences [15]\n\rATG4D Dataset [16] To simulate real-world driving scenario, the authors validate PnPNet on the ATG4D dataset. It contains over 5000 log snippets of 1000 unique journeys. Each snippet with LiDAR sweeps and HD maps. Also, only 48.1% of the cars are parked.\nModular Metrics For detection and tracking tasks, PnPNet follows tracking metrics introduced by nuScenes [15]. Detection task is measured in terms of average precision (AP) and tracking task in terms of MOT metrics, defined by Bernardin et al.[17].\nSystem Metrics Unlike predefined modular metrics, system metrics are defined by the PnPNet paper itself. For the perception task, average precision and maximum recall are used. For the prediction task, PnPNet uses average displacement error (ADE) and final displacement error (FDE). Both of these displacement errors are measured over 3 seconds, with ADE over a 0.5-second interval. Displacement error is simply the difference between the actual and the predicted location of an object.\nResults In this section, we look at the quantitative results, some ablation studies, and some qualitative results on PnPnet.\nQuantitative results Detection and tracking The detection module is evaluated on nuScenes in comparison to other SOA detections. PnPnet outperforms leading model Megvii[18] in most metrics. The tracking module is evaluated against the leading approach StanfordIPRL-TRI[19] and a PnPNet baseline with KF tracker replacing the tracking module. PnPnet outperforms [19] and KF tracker in MOT metrics.\n\rEvaluation of multi object tracking on nuScenes [1]\n\rEven though there are not many significant changes in the object detection module, PnPNet being an end-to-end model benefits this task too. A Better prediction model also fine-tunes the detection module. Improvements in the tracking model then influence the prediction task.\nPerception and prediction PnPnet is evaluated on both nuScenes and ATG4D for end-to-end perception and prediction. The paper establishes a baseline by removing the tracking module and denotes it as \u0026ldquo;PnPnet w/o track\u0026rdquo;. This implementation can be considered a re-implementation of [12]. The fast and furious (FAF)[12] is the direct predecessor of PnPNet. Classic PnPNet outperforms this baseline consistently across both datasets and all metrics, illustrating that keeping tracking in the loop allows for massive improvements in all tasks. \rEnd-to-End results on ATG4D and nuScenes [1]\n\rPnPNet observes up to 4.4 and 2.3 percentage increase in average precision and maximum recall respectively. For the prediction task, ADE is decreased up to 20% and FDE up to 15%.\nAblation studies Ablation studies are often conducted on end-to-end models to find out the individual contributions to the final result. PnPNet paper also conducts some ablation studies by removing motion features, sot, trajectory refinement, and the whole track module one byone.\n\rAblation studies on PnPNet [1]\n\rFrom the results of the studies, it is obvious that the tracking module has the largest effect on the prediction results. ADE and FDE go up to 18% percent in the absence of the tracking module. The trajectory rescore module influences average precision and displacement errors. The single object tracking module has a decent contribution across all the metrics.\nQualitative Results Well, these explanations are good and all but, where are the tangible results? Let's look at the visualization of perception and prediction results on ATG4D. This demonstrates that by learning trajectory representations explicitly, PnPNet is able to handle occlusion and produces robust predictions.\n\rQualitative results of [1]\n\rThis video was taken from the CVF youtube channel. The original video was the presentation for the PnPNet paper, which can be found here.\nSummary Earlier works in the realm of perception and prediction of autonomous driving have somewhat overlooked the contribution of trajectory information for future predictions. Although recent works do capitalize on the use of joint models, they leave tracking out of the loop. Following the footstep of these recent developments, PnPNet proposes a novel end-to-end training framework for perception and prediction while taking tracking into consideration. They also introduce a new tracking framework that can be looped into classic detection-prediction stacks. Their proposed improvements are then validated on different datasets and compared with other leading models in this paradigm. Finally, they show significant improvement in all three tasks as well as end-to-end performance.\nPersonal Remarks Using other recurrent units PnPNet uses an LSTM unit in the tracking module. However, as we know LSTMs need quite a bit of computation resources. In future works, other less expensive recurrent units can be explored for the same task. For example, GRU units [20] are computationally less expensive and have been proven to be comparable in terms of performance [21].\nAttention mechanism Recently many sequence modeling tasks are leveraging the attention mechanism. As we define our tracking as a sequential problem, it may be useful to apply self-attention on top of the recurrent unit outputs. Although this is not a pure sequence problem, self-attention may refine and provide importance to better trajectory features. Also, built-in attention [22] can be applied to the 2D-Convolutional backbone of the 3D detection algorithm.\nExcerpts from the Q\u0026amp;A In the paper, the authors limit the number of detection and tracks to a maximum of 50. But the PnPNet considers distances up to 100 meters. But, on busy roads usually far more moving objects within close proximity. The only way for PnPNet to consider this is to increase the N and M parameters. However, this again results in a massive number of computations for the Hungarian algorithm. The paper doesn't take this problem into account. Perhaps there could be more research in the tracking module so that the computation does not increase in the magnitude of NxM.\nReferences [1] Ming Liang, Bin Yang, Wenyuan Zeng, Yun Chen, Rui Hu, Sergio Casas, Raquel Urtasun, \"PnPNet: End-to-End Perception and Prediction with Tracking in the Loop\", in CVPR, 2020.\r[2] Bin Yang, Wenjie Luo, and Raquel Urtasun. Pixor: Realtime 3d object detection from point clouds. In CVPR, 2018.\r[3] Ming Liang, Bin Yang, Shenlong Wang, and Raquel Urtasun. Deep continuous fusion for multi-sensor 3d object detection. In ECCV, 2018.\r[4] Anton Milan, Konrad Schindler, and Stefan Roth. Multitarget tracking by discrete-continuous energy minimization. TPAMI, 38(10):2054–2068, 2015\r[5] Hasith Karunasekera, Han Wang, and Handuo Zhang. Multiple object tracking with attention to appearance, structure, motion and size. IEEE Access 7:104423–104434, 2019.\r[6] Peng Chu and Haibin Ling. Famnet: Joint learning of feature, affinity and multi-dimensional assignment for online multiple object tracking. In ICCV, 2019.\r[7] Wenwei Zhang, Hui Zhou, Shuyang Sun, Zhe Wang, Jianping Shi, and Chen Change Loy. Robust multi-modality multi-object tracking. In ICCV, 2019.\r[8] Michael D Breitenstein, Fabian Reichlin, Bastian Leibe, Esther Koller-Meier, and Luc Van Gool. Online multiperson tracking-by-detection from a single, uncalibrated camera. TPAMI, 33(9):1820–1833, 2010.\r[9] Alexandre Alahi, Kratarth Goel, Vignesh Ramanathan, Alexandre Robicquet, Li Fei-Fei, and Silvio Savarese. Social lstm: Human trajectory prediction in crowded spaces. In CVPR, 2016.\r[10] Agrim Gupta, Justin Johnson, Li Fei-Fei, Silvio Savarese, and Alexandre Alahi. Social gan: Socially acceptable trajectories with generative adversarial networks. In CVPR, 2018.\r[11] Nicholas Rhinehart, Rowan McAllister, Kris Kitani, and Sergey Levine. Precog: Prediction conditioned on goals invisual multi-agent settings. In ICCV, 2019. [12] Wenjie Luo, Bin Yang, and Raquel Urtasun. Fast and furious: Real time end-to-end 3d detection, tracking and motion forecasting with a single convolutional net. In CVPR, 2018.\r[13] Wenyuan Zeng, Wenjie Luo, Simon Suo, Abbas Sadat, Bin Yang, Sergio Casas, and Raquel Urtasun. End-to-end interpretable neural motion planner. In CVPR, 2019.\r[14] Luca Bertinetto, Jack Valmadre, Joao F Henriques, Andrea Vedaldi, and Philip HS Torr. Fully-convolutional siamese networks for object tracking. In ECCV, 2016.\r[15] Holger Caesar, Varun Bankiti, Alex H. Lang, Sourabh Vora, Venice Erin Liong, Qiang Xu, Anush Krishnan, Yu Pan, Giancarlo Baldan, and Oscar Beijbom. nuscenes: A multimodal dataset for autonomous driving. In CVPR, 2020.\r[16] Bin Yang, Wenjie Luo, and Raquel Urtasun. Pixor: Realtime 3d object detection from point clouds. In CVPR, 2018.\r[17] Keni Bernardin, Alexander Elbs, and Rainer Stiefelhagen. Multiple object tracking performance metrics and evaluation in a smart room environment. In Sixth IEEE International Workshop on Visual Surveillance, in conjunction with ECCV, 2006. \r[18] Benjin Zhu, Zhengkai Jiang, Xiangxin Zhou, Zeming Li, and Gang Yu. Class-balanced grouping and sampling for point cloud 3d object detection. arXiv preprint arXiv:1908.09492, 2019\r[19] Hsu-kuang Chiu, Antonio Prioletti, Jie Li, and Jeannette Bohg. Probabilistic 3d multi-object tracking for autonomous driving. arXiv preprint arXiv:2001.05673, 2020.\r[20] Kyunghyun Cho, Bart van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, Yoshua Bengio. Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation, In EMNLP 2014.\r[21] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, Yoshua Bengio. Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling. In NIPS 2014 Deep Learning and Representation Learning Workshop.\r[22] Niamul Quader, Md Mafijul Islam Bhuiyan, Juwei Lu, Peng Dai,and Wei Li. Weight Excitation: Built-in Attention Mechanisms in Convolutional Neural Networks. In ECCV 2020.\r","date":1619357812,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1619357812,"objectID":"33fbeff8369f57c659e04183d208b6e3","permalink":"https://abyaadrafid.github.io/post/pnpnet/","publishdate":"2021-04-25T19:36:52+06:00","relpermalink":"/post/pnpnet/","section":"post","summary":"In this post, we will be looking at the paper PnPNet: End-to-End Perception and Prediction with Tracking in the Loop, by Liang et al., which was published in CVPR 2020 [1]. After defining our task and discussing some related research in this field, we will be looking at the methodology of the paper. Then we will analyze the quantitative results and have a look at the qualitative results. Finally, we will finish it off with some remarks and possible ideas for extension.","tags":["Deep Learning","Computer Vision"],"title":"PnPNet: End-to-End Perception and Prediction With Tracking in the Loop","type":"post"},{"authors":["Rafid Abyaad","Rayhan Kabir","Sakib Hasan"],"categories":[],"content":"","date":1603631247,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603631247,"objectID":"491633cf92b5c195bd68991cdf103706","permalink":"https://abyaadrafid.github.io/publication/a-novel-approach-to-categorize-news-articles-from-headlines-and-short-text/","publishdate":"2020-10-25T19:07:27+06:00","relpermalink":"/publication/a-novel-approach-to-categorize-news-articles-from-headlines-and-short-text/","section":"publication","summary":"Over the last few years the world has experienced a surge in the number of online news portals. This has caused the volume of news articles to reach an all time high; which will only get higher with time. Thus, an efficient system of categorization and organization of the articles has become a necessity for various information systems like- news aggregation and association in search engines. It is impractical to employ humans to label this expansive volume of text data, prompting the growth of automated text categorization systems. And so, we devised a deep learning model that effectively categorizes news articles from the headlines and short text descriptions. The prime foci of our work were to design, develop, and measure the performance metrics of our proposed model.","tags":["Deep Learning","Natural Language Processing"],"title":"A Novel Approach to Categorize News Articles From Headlines and Short Text","type":"publication"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"b6afff65cefee68f1ef97e7a75460306","permalink":"https://abyaadrafid.github.io/project/a3c/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/a3c/","section":"project","summary":"Implementation of Advantage Actor Critic to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning"],"title":"Advantage Actor Critic","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"44d73dd2341776ad24b5af09172e1979","permalink":"https://abyaadrafid.github.io/project/dqn/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/dqn/","section":"project","summary":"Implementation of Deep Q Learning to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning"],"title":"Deep Q Learning","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"11b36ddbf4444780eb53371c6c17dae6","permalink":"https://abyaadrafid.github.io/project/ddqn/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/ddqn/","section":"project","summary":"Implementation of Double Deep Q Learning to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning"],"title":"Double Deep Q Learning","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"e3c9df9bcde44c5e1ac3b0bfa9f68e6f","permalink":"https://abyaadrafid.github.io/project/duellingdqn/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/duellingdqn/","section":"project","summary":"Implementation of Dueling Deep Q Learning to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning"],"title":"Dueling Deep Q Learning","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"c31dfbe4ed44b15c1297c1bb5a4629c4","permalink":"https://abyaadrafid.github.io/project/d3qn/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/d3qn/","section":"project","summary":"Implementation of Dueling Double Deep Q Learning to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning"],"title":"Dueling Double Deep Q Learning","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"e0422b3d74b12c850079abd22d7e0a25","permalink":"https://abyaadrafid.github.io/project/reinforce/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/reinforce/","section":"project","summary":"Implementation of REINFORCE to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning","Policy Gradient"],"title":"Policy Gradient (REINFORCE)","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"0999d97abbf45d09dd9473fc45f4d526","permalink":"https://abyaadrafid.github.io/project/sac/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/sac/","section":"project","summary":"Implementation of SAC to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning","Policy Gradient"],"title":"Soft Actor Critic","type":"project"},{"authors":null,"categories":null,"content":"","date":1590343200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590343200,"objectID":"908bcec67591270e2510435168c5d2d8","permalink":"https://abyaadrafid.github.io/project/valueac/","publishdate":"2020-05-25T00:00:00+06:00","relpermalink":"/project/valueac/","section":"project","summary":"Implementation of Value Actor Critic to solve OpenAI LunarLander environment","tags":["Deep Learning","Reinforcement Learning","Policy Gradient"],"title":"Value Actor Critic","type":"project"},{"authors":null,"categories":null,"content":"This was one my of very first competitions. While doing Practical Deep Learning for Coders, this competition provided a good source of practise. It was a binary classification problem. The goal for this competition was to determine whether the given satellite image contained a columnur cactus.\nI used this dataset for two purposes :\n To implement and test ArcFace using pytorch. To get placed into a high LeaderBoard position in the competition using FastAI.  Approach EDA According to the dataset details, the images were taken from the air. The images are low-res, some of them rotated to arbitrary angles and some zoomed. From visual inspection, the cacti are somewhat easy to spot because of their unique texture and stick-like shape. The class imbalance is not severe, can be handled by data augmentation.\nData split and Transforms Split As the class imbalance was not servere, the data could be split into train/valid set at random.\nTransforms Following Transforms were applied with 75% probability to augment the data, then the images were resized to 128*128. Test time augmentation was not applied.\n Horizontal Flip Vertical Flip Left and Right rotation upto 10° Upto 110% zoom  Hyperparameters ArcFace  s = 64 m = 0.0 Adam Optimizer with fixed lr = 1e-3  Competition Classifiers Densenet169  Frozen model, Adam optimizer with maximum lr = 7.5e-3. CyclirLR scheduler Unfrozen model, Adam optimizer with maximum lr = 1e-6.  Resnet101  Frozen model, Adam optimizer with maximum lr = 9e-3. CyclirLR scheduler Unfrozen model, Adam optimizer with maximum lr = 1e-6.  Model Performance I used DenseNet169 and Resnet101 for Leaderboard and ArcFace for research purposes.\nArcFace ArcFace was applied on the Resnet101 backbone. Implemented from scratch in pytorch. With embedding dimension = 2048 and scale_factor (s) = 64, accuracy follows :\nFurther experimentation using additional linear layers can boost the results. Then again, this approach is designed for one-shot learning. Worse performance in Binary Classification is quite understandable.\nDenseNet169 Densenet169 needs more time to converge because of its enormous size and paramters.\n   epoch train_loss valid_loss error_rate accuracy time     0 0.059754 0.004154 0.000000 1.000000 01:35   1 0.062731 0.000837 0.000000 1.000000 01:29   2 0.019187 0.003954 0.000000 1.000000 01:29   3 0.009922 0.000457 0.000000 1.000000 01:26   4 0.004491 0.000055 0.000000 1.000000 01:27    Resnet101 Resnet101 needed less time to converge.\n   epoch train_loss valid_loss error_rate accuracy time     0 0.063169 0.033260 0.011429 0.988571 01:17   1 0.034835 0.002770 0.000000 1.000000 01:15   2 0.024171 0.002123 0.000000 1.000000 01:15   3 0.014281 0.006416 0.005714 0.994286 01:14   4 0.006923 0.002465 0.000000 1.000000 01:13    Competition Standings My models acheived perfect accuracy score in the public leaderboard.\n","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"8d5e5566ce7ce6a7ce03de14fc5b29c8","permalink":"https://abyaadrafid.github.io/project/acic/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/acic/","section":"project","summary":"Approaches and code for identifying cacti from satellite images","tags":["Deep Learning","Computer Vision"],"title":"Aerial Cactus Identification","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"2e8099fdeae20f08476661bf7e6574e4","permalink":"https://abyaadrafid.github.io/project/aptos/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/aptos/","section":"project","summary":"Description of approaches for the APTOS medical image classification Competition","tags":["Deep Learning","Computer Vision"],"title":"APTOS Blindness Detection","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"42a36e94cfdd683e6c065cf82a611878","permalink":"https://abyaadrafid.github.io/project/f360/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/f360/","section":"project","summary":"Classifying fruits using computer vision models","tags":["Deep Learning","Computer Vision"],"title":"Computer Vision 101","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"cc85f6ff0839f6d222f0b11bba9c684d","permalink":"https://abyaadrafid.github.io/project/ferm/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/ferm/","section":"project","summary":"Vision model to classify facial expression","tags":["Deep Learning","Computer Vision"],"title":"Facial Expression Recognition","type":"project"},{"authors":null,"categories":null,"content":"The problem for this competition was text binary classification. The goal of this competition was to develop a model that can flag potentially toxic/insincere questions. Being a kernel-only competition, models available memory and execution time was limited for submissions. I developed a model and submitted it to the competition after it had ended. The submissions placed me at :\n Public LB : Top 50 Private LB : Top 100  Aproach EDA Initial EDA of the data revealed the dataset to be very imbalanced. Around 96% of the data was from one class and the rest from the other. So accuracy as a metric was useless in this particular competition. The evaluation criteria was to maximized F-score, rightly so.\nText Preprocessing and Loading The competition provided word embedding files. To use the word embeddings, I needed to make sure that word coverage is as much as possible. That meant I needed to fix word misspellings and typos. Glove and Paragram word embeddings do not include many punctuations present in the dataset, so I needed to remove them as well.\nProcessing Steps  Cleaning Text from numbers and Punctuations Replacing typical misspellings and typos Filling blank questions with special tokens  Crafting Meta Features Based on some EDA, these features are extracted from the train data :\n Total length Capitals Ratio of capitals and length Number of words Number of unique words Ratio of unique words and total words  Tokenization I used keras tokenizer. All out of vocabulary words will be replaced with special \u0026lsquo;xxunk\u0026rsquo; token. Tokenizer is fit on the train data and used to make sequence of texts. Then the sequences are padded so all of them have the same length. Longer sequences are truncated and shorter ones are padded.\nScaling Statistical Features Calculated Statistical Features will have to be scaled before putting through a neuralnet.\nAs because these features have different ranges for values, some features may produce vanishing gradients. For example number of words will be, on average, a way larger value than number of unique words. So, these feaures are scaled using a standard scaler.\nLoading Embeddings I have used paragram and glove embeddings in the model. As these word embeddings were not trained in exactly the same system, some useful information may be lost if a weighted average is used. That is why, I have concatenated them into a num_words * (embedding_dim * num_embedding) matrix.\nUsing more embeddings may end up giving more generalization but these models are quite memory intensive and used all my ram. So I couldn't use more than two of them.\nModel Definition Modules Following Modules contruct the model :\n Embedding and Dropout LSTM+GRU backbone Attention Block Extractor/ Merge Layer Output/ Head  Embedding and Dropout This layer takes truncated sequence of tokenized texts as input and provides a 2d array as output. In my case I limited 120000 as the maximum number of unique features to use. A dropout of 10% was applied. This module returns an array of size (120000 * 300 * 2)\nLSTM+GRU and Attention Backbone The main body of the model consists of bidirectional LSTM and GRU (128). The body returns LSTM+GRU outputs and Attention-transformed LSTM+GRU outputs.\nExtractor/ Merge This layer serves as the feature extractor for lstm, gru outputs and statistical Meta features. Conv1d is applied on lstm output, which goes into a maxpool. GRU output is sent through avgpool. Statistical Features are put through a Linear layer.\nOutput Layer This layer consists of a dropout, a relu and a batchnorm layer, sandwiched between two linear layers. The last linear layer provides the output of the model as a score for the input.\nComplete Model  First input is sent through embedding layer, returning feature vectors. Embedding output is then passed to the Body of the model. Extractor layer is used to find features from the sequential output of the model backbone. Attention infused lstm+gru outputs and extracted features are concatenated. Concatenated features are sent to the output layer.  Training the model The model was trained 5 epochs with Stratified 5-fold-cross-validation. Adam optimizer with 0.01 learning rate and ExponentialLR scheduler was used.\nBest threshold for classification The sigmoid value provided by the model is a continuous representation of insincerity in the inputs. We need a specific threshold to separate the two classes. The best threshold was calculated on the training data, then it was applied on the test data. Based on the threshold of the score, test data was classified and submitted.\n","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"18caf11feb3d42b782388c06871ef47b","permalink":"https://abyaadrafid.github.io/project/qiqc/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/qiqc/","section":"project","summary":"Approaches and codes for short-text binary classification","tags":["Deep Learning","Natural Language Processing"],"title":"Quora Insincere Questions Classification","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"3120f353182d7ece615b5b2ccb8efe44","permalink":"https://abyaadrafid.github.io/project/rcic/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/rcic/","section":"project","summary":"Recursion Cellular Image Classification","tags":["Deep Learning","Computer Vision"],"title":"Recursion Cellular Image Classification","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"9ef400c9f2227de4b0609d72306fcc5c","permalink":"https://abyaadrafid.github.io/project/siim-acr/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/siim-acr/","section":"project","summary":"SIIM-ACR Pneumothorax Segmentation","tags":["Deep Learning","Computer Vision"],"title":"SIIM-ACR Pneumothorax Segmentation","type":"project"},{"authors":null,"categories":null,"content":"","date":1577210400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577210400,"objectID":"0e59012bbcdad557cc798c391f506609","permalink":"https://abyaadrafid.github.io/project/dmnist/","publishdate":"2019-12-25T00:00:00+06:00","relpermalink":"/project/dmnist/","section":"project","summary":"Performance analysis of Tabular vs Vision models on Digits-MNIST dataset","tags":["Deep Learning","Computer Vision","Tabular Model"],"title":"Tabular vs Vision Models","type":"project"}]